NAME
    Dist::Zilla::UtilRole::MaybeZilla - Soft-dependency on Dist::Zilla for
    Utilities.

VERSION
    version 0.001000

DESCRIPTION
    Dzil Is Great. But when you're writing a utility class, loading
    Dist::Zilla may be not necessary, and can make testing things harder.

    Namely, because to test anything that requires "Dist::Zilla", requires
    that you have a valid build tree, which may be lots of unecessary work
    if you only need "dzil" for simple things like error logging.

    Or perhaps, you have other resources that you only conventionally fetch
    from "dzil", such as the "dzil build-root", for the sakes of making a
    "Git::Wrapper", but you're quite happy with passing "Git::Wrapper"
    instances directly for testing.

    And I found myself doing quite a lot of the latter, and re-writing the
    same code everwhere to do it.

    So, this role provides a "zilla" attribute that is ONLY required if
    something directly calls "$self->zilla", and it fails on invocation.

    And provides a few utility methods, that will try to use "zilla" where
    possible, but fallback to a somewhat useful default if those are not
    available to you.

        package MyPlugin;
        use Moose;
        with 'Dist::Zilla::UtilRole::MaybeZilla';

        ...

        sub foo {
            if ( $self->has_zilla ) {
                $self->zilla->whatever
            } else {
                $slightlymessyoption
            }
        }

    Additionally, it provides a few compatibility methods to make life
    easier, namely

        log_debug, log, log_fatal

    Which will invoke the right places in "dzil" if possible, but revert to
    a sensible default if not.

METHODS
  "logger_name_suffix"
    Because "::Util" are intended to be created in multiples, as attributes
    on objects ( Well, at least the one this role is targeted at ), it seems
    natural that plugins will have child utilities, and child utilities will
    have thier own children.

    So the internal system "dzil" uses for prefixing won't be enough to know
    where a log message is comming from, because "dzil" only reports the
    plugin itself.

    So instead, we have a private method "_logger_prefix", that combines
    either of "$plugin->plugin_name" or "$plugin->_logger_prefix" with
    "logger_name_suffix" so that each child will inherit its path from its
    parent.

        Dist::Zilla::Plugin::Foo  -> [Foo]
        →  attr thingy    = Object Dist::Zilla::Util::Thingy w/ plugin = Foo
        →                   [Foo/Thingy]
        → → attr bar      = Object Dist::Zilla::Util::Thingy w/ plugin = Foo/thingy
        → →               = [Foo/Thingy/Thingy]

    Ok, pretty poor example. But you get the idea.

    "logger_name_suffix" only controls the *last* token on that list.

    The other tokens are based on "plugin" ( And of course, only where
    possible ).

ATTRIBUTES
  "zilla"
    A lazy attribute, populated from "plugin" where possible, fatalizing if
    not.

  "plugin"
    A lazy attribute that fatalizes if required and not specified.

  "logger"
    Creates a Logger object, but the implementation details differ based on
    availability of "zilla" and "plugin"

    Provides:

        log, log_debug, log_fatal

AUTHOR
    Kent Fredric <kentfredric@gmail.com>

COPYRIGHT AND LICENSE
    This software is copyright (c) 2013 by Kent Fredric
    <kentfredric@gmail.com>.

    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.

